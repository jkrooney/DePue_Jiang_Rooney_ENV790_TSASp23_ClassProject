---
title: "Visionary Final"
author: "Justin DePue, John Rooney, and Tony Jiang"
date: "`r Sys.Date()`"
output: pdf_document
toc: TRUE
geometry: margin=2.54cm
fig_height: 3
fig_width: 4
---

- Knitting commands in code chunks:
  -  `include = FALSE` - code is run, but neither code nor results appear in knitted file
  -  `echo = FALSE` - code not included in knitted file, but results are
  -  `eval = FALSE` - code is not run in the knitted file
  -  `message = FALSE` - messages do not appear in knitted file
  -  `warning = FALSE` - warnings do not appear...
  -  `fig.cap = "..."` - adds a caption to graphical results

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r loading libraries, warning = FALSE, message = FALSE, include = FALSE}
library(tseries)
library(lubridate)
library(here)
library(tidyverse)
library(ggplot2)
library(forecast)
library(kableExtra)
library(readxl)

```


##Introduction
This study was born out of both curiosity and necessity. One of our teammates faced higher than expected energy bills this winter and was suddenly faced with the question of whether to shiver to save money or spend it on heating bills and be forced to eat Spaghetti-O's as sustenance. While spring has sprung and summer is on the horizon, we know that winter is coming and that we should prepare now in order that history not repeat itself. 

As students recently armed with the tools to conduct time series analysis and forecasting, we realized we could complete our final project while aiding our teammate with knowledge for the future. Our study question thus emerged: would it be more cost-effective to heat an apartment in North Carolina using electricity or a natural-gas powered heater? 

Full of optimism that we could complete a class requirement while doing some good for the world (for as Marvel taught us, when you help someone, you help everyone), we set out to find the data that would lead us to the answer we sought. Our journey led us to that great repository of energy knowledge, the US Energy Information Administration. There we found two datasets we felt confident would help us help our teammate: "North Carolina Price of Natural Gas Delivered to Residential Customers (Dollars Per Thousand Cubic Feet)", which contained monthly data from January 1989 through January 2023, and "Average Retail Price of Electricity by State and Sector" which contained monthly data from January 2001 through January 2023. 

##Data
```{r load and explore data, warning=FALSE, include=FALSE}

# automatically set the working directory as personal local path to R project
# so the file path in read.csv can work for everyone
setwd(here())

# load the data
electricity_prices.df <- read.csv("./Data/Average_retail_price_of_electricity.csv", header = TRUE, skip=4)

nc_electricity.df<-electricity_prices.df[228,4:(ncol(electricity_prices.df))] %>%
  pivot_longer(cols=everything(), names_to = 'my_date', values_to = 'price_per_kWh')

# examine whether there is missing value or not
summary(nc_electricity.df)
# there is no missing value

nc_electricity.df$price_per_kWh<-as.numeric(nc_electricity.df$price_per_kWh)
  

# Import Natural Gas data

natural_gas.df <- read.csv("./Data/NC_NaturalGas.csv", header = TRUE, skip=2,col.names = c("year", "price"))

#Check for missing data. There is an extra row with an NA at the end of the data, so I removed it with na.omit

summary(na.omit(natural_gas.df))
str(natural_gas.df)

```

##Analysis
We first created initial time series objects and plotted them, along with ACF and PACF plots to gain an initial sense of what the series looked like and what seasonality they may have.  

```{r create time series for natural gas, include=FALSE}
#create timeseries for natural gas

ts_NG<-ts(na.omit(natural_gas.df[,2]), start=c(1989,1), frequency=12)
```

```{r plot initial time series, includ=FALSE}
# plot raw time series
plot(ts_NG, col="blue", ylab="$/Mcf", xlab="Date", main="NC Residential Natural Gas Cost")
```

```{r, warning=FALSE, include=FALSE}
# convert natural gas data from $/Mcf to $/kWh based on 80% heating efficiency
# $/kWh = [($/mcf/1.037)/293.07107]/0.9 = $/mcf/273.52


conversion <- 0.8*293.07107*1.037/100


natural_gas.df$kwh_equiv<-((natural_gas.df$price)/conversion)


natural_gas.df<-na.omit(natural_gas.df)

ts_gas_equiv<-ts(natural_gas.df[,3], start=c(1989,1), frequency=12)

ts_gas_equiv<-window(ts_gas_equiv, start=c(2001, 1))

#plot gas TS in kw/hr equiv
autoplot(ts_gas_equiv) +
  ylab("Price (cents/kWh") + 
  ggtitle("NC Residential Natural Gas Cost (cents/kWh)")


# coerce electricity to a time series object

ts_electricity<-ts(rev(nc_electricity.df[,2]), start=c(2001,1), frequency=12)

plot(ts_electricity, col="red", ylab="Price (cents/kWh)", xlab="Date", main="NC Residential Electricity Cost")


#Create Dataframe with both Gas & Electricity prices...
#create new date column
new_date<-seq(as.Date("2001/1/1"), by = "month", length.out = nrow(ts_electricity))

#bind date, gas, & electricity
nc_energy.df<-cbind.data.frame("Month_Date"=new_date, 
                               "electricity"=nc_electricity.df$price_per_kWh, 
                               "gas_equiv"=ts_gas_equiv)

#Subtract Gas price from Electricity price
nc_energy.df$cost_diff <- nc_energy.df$electricity - nc_energy.df$gas_equiv

```

```{r plot elec and gas ts, echo=FALSE}
#plot both electric & gas TS together
ts.plot(ts_gas_equiv, ts_electricity, gpars = list(col = c("red", "blue")), 
        xlab="Date", ylab="cents/kWh", 
        main="Comparison of Natural Gas and Electricity Costs")
legend("topleft", bty="n", lty=c(1,1), col=c("red","blue"),
       legend=c(" Natural Gas ", " Electricity "))
```

```{r ACF and PACF of electricity and natural gas, echo=FALSE}

# ACF and PACF of electricity data
par(mfrow=c(1,2))
Acf(ts_electricity[,2], lag.max=40, main="ACF Electricity")
Acf(ts_elec_ns, lag.max=40, main="ACF Non-Seasonal Electricity")

par(mfrow=c(1,2))
Pacf(ts_electricity[,2], lag.max=40, main="PACF Electricity")
Pacf(ts_elec_ns, lag.max=40, main="PACF Non-Seasonal Electricity")

# ACF and PACF of natural gas data
par(mfrow=c(1,2))
Acf(ts_gas_equiv[,1], lag.max=40, main="ACF Natural Gas")
Acf(ts_gas_ns, lag.max=40, main="ACF Non-Seasonal Gas")

par(mfrow=c(1,2))
Pacf(ts_gas_equiv[,1], lag.max=40, main="PACF Natural Gas")
Pacf(ts_gas_ns, lag.max=40, main="PACF Non-Seasonal Gas")
```

We then decomposed the time series objects for further analysis. 

```{r decompose ts, echo=FALSE}
#Decompose TS

decomp_elec<-decompose(ts_electricity[,2], type="additive")
decomp_gas<-decompose(ts_gas_equiv[,1], type="multiplicative")

ts_gas_equiv[,1] %>% 
  window(start = c(2013,1), end = c(2023,1)) %>%
  stl(s.window = "periodic") %>% 
  plot()

plot(decomp_elec)

#remove seasonality
ts_elec_ns<-(ts_electricity[,2] - decomp_elec$seasonal)
ts_gas_ns<-(ts_gas_equiv[,1] - decomp_gas$seasonal)

```


Several models were developed and tested to determine what would best fit the data we had and what may lead to the best forecast to determine whether heating via electricity or natural gas would be most cost-efficient in the upcoming winter. The five that were used were the Seasonal ARIMA, ARIMA with Fourier terms, Neural Networks, TBATS, and STL + EST.

Each of these tests used functions from the "forecast" library and required the use of time series data which we created using the "ts" function from the "tseries" library.

While the Seasonal ARIMA was a logical first model to try, we quickly felt that the performance was not particularly strong. 

```{r Seasonal Arima, echo=FALSE}
#forecast Electricity SARIMA

arima.e.model<-auto.arima(window(ts_electricity[, 2], end=c(2022,1)))
arima.e.forecast<-forecast(arima.e.model, h=12)

autoplot(ts_electricity[, 2]) +
  autolayer(arima.e.forecast$mean, series = "SARIMA") +
  ylab("Price (cents/kWh)") +
  ggtitle("Electricity - SARIMA")
  # performance is not that good

#Gas SARIMA forecast
arima.gas.model<-auto.arima(window(ts_gas_equiv[, 1], end=c(2022,1)))
arima.gas.forecast<-forecast(arima.gas.model, h=12)

autoplot(ts_gas_equiv[, 1])+
  autolayer(arima.gas.forecast$mean, series = "SARIMA") +
  ylab("Price (cents/kWh)") +
  ggtitle("Natural Gas - SARIMA")
  # performance is not that good
```

```{r examine SARIMA performance}

# model performance for electricity data
sarima_e_perf <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(arima.e.forecast$mean)


# model performance for gas data
sarima_gas_perf <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(arima.gas.forecast$mean)

```
We decided to explore more advanced models that could handle the ARIMA with Fourier Terms model, Neural Networks, TBATS, and STL + EST.
ARIMA with Fourier terms is known as a dynamic harmonic regression model with an ARMA error structure, using the "fourier" function from package "forecast" to find terms that model seasonal components. 

```{r Arima with Fourier terms}
# arima with fourier terms for eletricity
arima.e.four.forecast <- ts_electricity[, 2] %>% 
  window(end = c(2022, 1)) %>% 
  auto.arima(seasonal = FALSE, 
             xreg = fourier(window(ts_electricity[, 2], end = c(2022, 1)), 
                            K = 6)) %>% 
  forecast(xreg = fourier(window(ts_electricity[, 2], 
                                 start = c(2022,2)
                                 ),
                            K = 6),
           h = 12)

autoplot(arima.e.four.forecast$mean, series = "ARIMA with Fourier Terms") +
  autolayer(ts_electricity[, 2], series = "Historical Data") +
  ggtitle("Electricity - ARIMA with Fourier Terms") +
  ylab("Price (cents/kWh)")

# arima with fourier terms for gas
arima.gas.four.forecast <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022, 1)) %>% 
  auto.arima(seasonal = FALSE,
             xreg = fourier(window(ts_gas_equiv[, 1], end = c(2022, 1)), 
                            K = 6)
             ) %>% 
  forecast(xreg = fourier(window(ts_gas_equiv[, 1], 
                                 start = c(2022, 2)
                                 ),
                          K = 6), 
           h = 12)

autoplot(arima.gas.four.forecast$mean, series = "ARIMA with Fourier Terms") +
  autolayer(ts_gas_equiv[, 1], series = "Historical Data") +
  ggtitle("Natural Gas - ARIMA with Fourier Terms") +
  ylab("Price (cents/kWh)")

```

```{r Examine Arima with fourier's performance on electricity and NG data}

# model performance for electricity data
arima_four_e_perf <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(arima.e.four.forecast$mean)

# model performance for gas data
arima_four_gas_perf <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(arima.gas.four.forecast$mean)

```

Then we tried STL model
```{r Use STL to model}

# STL for electricity
stl.e.forecast <- ts_electricity[, 2] %>% 
  window(end = c(2022, 1)) %>% 
  stlf(h = 12)

autoplot(stl.e.forecast$mean, series = "STL + ETS") +
  autolayer(ts_electricity[, 2], series = "Historical Data") +
  ggtitle("Electricity - STL + EST") +
  ylab("Price (cents/kWh)")

# STL for gas
stl.gas.forecast <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022, 1)) %>% 
  stlf(h = 12)

autoplot(ts_gas_equiv[, 1], series = "Historical Data") +
  autolayer(stl.gas.forecast$mean, series = "STL + ETS") +
  ggtitle("Natural Gas - STL + EST") +
  ylab("Price (cents/kWh)")
```


```{r Examine STL's performance on electricity and NG data}

# model performance for electricity data
stl_e_perf <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(stl.e.forecast$mean)

# model performance for gas data
stl_gas_perf <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(stl.gas.forecast$mean)

```

Then we tried to use neural network model. We used nnetar() in forecast package. We figured out p and P arguments in nnetar() have significant impact on model performance. Therefore, we first tried to identify the optimal p and P conbination by trying different combinations.


```{r }
# find the optimal p and P values for neural network without fourier for electricity series

## p = 1, P = 0
nn.e.forecast.10 <- ts_electricity[, 2] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 0, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.10.score <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.10$mean)

## p = 1, P = 1
nn.e.forecast.11 <- ts_electricity[, 2] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.11.score <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.11$mean)

## p = 2, P = 0
nn.e.forecast.20 <- ts_electricity[, 2] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 0, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.20.score <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.20$mean)

## p = 2, P = 1
nn.e.forecast.21 <- ts_electricity[, 2] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.21.score <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.21$mean)

## p = 2, P = 2
nn.e.forecast.22 <- ts_electricity[, 2] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 2, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.22.score <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.22$mean)

## p = 1, P = 2
nn.e.forecast.12 <- ts_electricity[, 2] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 2, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.12.score <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.12$mean)

## p = 3, P = 1
nn.e.forecast.31 <- ts_electricity[, 2] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 3, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.31.score <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.31$mean)

nn.e.scores <- rbind(nn.e.10.score, nn.e.11.score, nn.e.20.score, nn.e.21.score,
                   nn.e.22.score, nn.e.12.score, nn.e.31.score)

row.names(nn.e.scores) <- c("10", "11", "20", "21", "22", "12", "31")

nn.e.scores ## 11 has the lowest RMSE and 12 has the lowest MAPE

# we can do the same thing to natural gas. Do we want to??

```

```{r }
# find the optimal p and P values for neural network without fourier for natural gas series

## p = 1, P = 0
nn.gas.forecast.10 <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 0, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.10.score <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.10$mean)

## p = 1, P = 1
nn.gas.forecast.11 <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.11.score <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.11$mean)

## p = 2, P = 0
nn.gas.forecast.20 <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 0, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.20.score <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.20$mean)

## p = 2, P = 1
nn.gas.forecast.21 <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.21.score <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.21$mean)

## p = 2, P = 2
nn.gas.forecast.22 <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 2, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.22.score <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.22$mean)

## p = 1, P = 2
nn.gas.forecast.12 <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 2, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.12.score <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.12$mean)

## p = 3, P = 1
nn.gas.forecast.31 <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 3, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.31.score <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.31$mean)

## p = 3, P = 2
nn.gas.forecast.32 <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 3, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.32.score <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.32$mean)

## p = 3, P = 3
nn.gas.forecast.33 <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 3, P = 3, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.33.score <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.33$mean)

nn.gas.scores <- rbind(nn.gas.10.score, nn.gas.11.score, nn.gas.20.score, nn.gas.21.score,
                   nn.gas.22.score, nn.gas.12.score, nn.gas.31.score, nn.gas.32.score, 
                   nn.gas.33.score)

row.names(nn.gas.scores) <- c("10", "11", "20", "21", "22", "12", "31", "32", "33")

nn.gas.scores ## 32 has the lowest RMSE and 11 has the lowest MAPE

```

We found that the combination 11 (p = 1 and P = 1) has the best modeling performance for electricity series, and the combination 32 (p = 3 and P = 2) has the best modeling performance for natural gas series. Then we use this combination to run the neural network model with fourier terms for elecricity series.

```{r Use Neural Network and fourier to model}
# neural network forecast for electricity data
nn.e.forecast <- ts_electricity[, 2] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         xreg = fourier(window(ts_electricity[, 2], 
                               end = c(2022, 1)
                               ),
                        K = 6)
         ) %>% 
  forecast(xreg = fourier(window(ts_electricity[, 2], 
                                 start = c(2022, 2)
                                 ),
                          K = 6),
           h = 12)

# neural network forecast for gas data
nn.gas.forecast <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 3, P = 2,
         xreg = fourier(window(ts_gas_equiv[, 1], 
                               end = c(2022, 1)
                               ),
                        K = 6)
         ) %>% 
  forecast(xreg = fourier(window(ts_gas_equiv[, 1], 
                                 start = c(2022, 2)
                                 ),
                          K = 6),
           h = 12)


autoplot(nn.e.forecast$mean, series = "Neural Network") +
  autolayer(ts_electricity[, 2], series = "Historical Data") +
  ggtitle("Electricity - Neural Network") +
  ylab("Price (cents/kWh)")

autoplot(nn.gas.forecast$mean, series = "Neural Network") +
  autolayer(ts_gas_equiv[, 1], series = "Historical Data") +
  ggtitle("Natural Gas - Neural Network") +
  ylab("Price (cents/kWh)")
```

```{r }
# neutral network model performance

# neural network model performance for electricity data
nn_e_perf <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast$mean)

# neural network model performance for gas data
nn_gas_perf <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast$mean)
```

Then we tried TBATS models for electricity and natural gas series
```{r }
# TBATS model

# TBATS for electricity
tbats.e.forecast <- ts_electricity[, 2] %>% 
  window(end = c(2022, 1)) %>% 
  tbats() %>% 
  forecast(h = 12)

# TBATS for natural gas
tbats.gas.forecast <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022, 1)) %>% 
  tbats() %>% 
  forecast(h = 12)

```

```{r }
# TBATS model performance

# neural network model performance for electricity data
tbats_e_perf <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(tbats.e.forecast$mean)

# neural network model performance for gas data
tbats_gas_perf <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(tbats.gas.forecast$mean)
```

Then we think Ukraine War should have a significant impact on natural gas price and probably eletricity gas too. Also, temperature should be a good regressor to include since utility bills normally fluctuate in the same direction with temperature. Therefore, we created two covariates: UKRWAR and temperature. $UKRWAR$ is an indiciator variable with values of 0 and 1. Months before March 2022 have a value of 0, while months after and including March 2022 have a value of 1. The reason why we set the cutoff month at March 2002 despite the war started from last February is because the impact of the war on monthly natural gas price in February 2022 should be limited since the war started in late February. The temperature series is the monthly average temperature of Raleigh area. This is largest geographic level of historical temperature data.
```{r include=F}
# add covariates

# create an indicator variable for Ukraine War for gas

# create a column with row index
natural_gas.df <- rownames_to_column(natural_gas.df, var = "index")

natural_gas.df$index = as.numeric(natural_gas.df$index)

natural_gas.df$UKRWAR <- ifelse(natural_gas.df$index >= 399, 1, 0)

natural_gas.df <- natural_gas.df[, c(-1, -6)]

ts_gas_equiv<-ts(natural_gas.df[,c(3,4)], start=c(1989,1), frequency=12) %>% 
  window(start = c(2001, 1))

# create an indicator variable for Ukraine War for electricity
nc_electricity.df <- rownames_to_column(nc_electricity.df, var = "index")

nc_electricity.df$index <- as.numeric(nc_electricity.df$index)

nc_electricity.df$UKRWAR <- ifelse(nc_electricity.df$index >= 255, 1, 0)

nc_electricity.df <- nc_electricity.df[, -1]

# coerce electricity to a time series object

ts_electricity<-ts(rev(nc_electricity.df[,2:3]), start=c(2001,1), frequency=12)


# import temperature data
temperautre <- read_xlsx("./Data/Raleigh Temperature.xlsx") %>% 
  gather(key = "Month", value = "temperature", Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)

temperautre <- temperautre[order(temperautre$Year), ] 

ts_temperature <- temperautre[,3] %>% 
  na.omit() %>% 
  ts(start = c(1995, 1), frequency = 12) %>% 
  window(start = c(2001, 1), end = c(2023, 1))

# create a data frame for covariates for electricity (2001-2022)
# we need to do this because electricity and natural gas 
# have different fourier terms
fourier_train_e <- fourier(window(ts_electricity[, 2],
                                end = c(2022, 1)),
                         K = 6)

covariates_train_e <- ts_electricity[, 1] %>% 
  window(end = c(2022, 1)) %>% 
  cbind(window(ts_temperature, end = c(2022,1)),
        fourier_train_e)


# create covariates data frame for electricity (2001-2023)
fourier_full_e <- fourier(window(ts_electricity[, 2],
                                end = c(2023, 1)),
                         K = 6)

covariates_full_e <- cbind(ts_electricity[, 1], ts_temperature, fourier_full_e)

# create covariates data frame for natural gas (2001-2022)
fourier_train_gas <- fourier(window(ts_gas_equiv[, 1],
                                end = c(2022, 1)),
                         K = 6)

covariates_train_gas <- ts_gas_equiv[, 2] %>% 
  window(end = c(2022, 1)) %>% 
  cbind(window(ts_temperature, end = c(2022,1)
               ),
        fourier_train_gas)


# create covariates data frame for electricity (2001-2023)
fourier_full_gas <- fourier(window(ts_gas_equiv[, 1],
                                end = c(2023, 1)),
                         K = 6)

covariates_full_gas <- cbind(ts_gas_equiv[, 2], ts_temperature, fourier_full_gas)
  
```

After creating all the covariates, we repeated our modeling but with covariates to improve the accuracy of the models. First we incorporated covairates to neural network model. 

```{r}
# Use Neural Network, temperature, UKRWAR, and fourier to model

# neural network forecast for electricity data
nn.cov.e.forecast <- ts_electricity[, 2] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 1,
         xreg = covariates_train_e[, -1]) %>% 
  forecast(xreg = window(covariates_full_e[, -1], start = c(2022, 2)),
           h = 12)

# neural network forecast for gas data
nn.cov.gas.forecast <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 1,
         xreg = covariates_train_gas[, -1]) %>% 
  forecast(xreg = window(covariates_full_gas[, -1], start = c(2022, 2)),
           h = 12)

autoplot(nn.cov.e.forecast$mean, series = "Neural Network") +
  autolayer(ts_electricity[, 2], series = "Historical Data") +
  ggtitle("Electricity - Neural Network") +
  ylab("Price (cents/kWh)")

autoplot(nn.cov.gas.forecast$mean, series = "Neural Network") +
  autolayer(ts_gas_equiv[, 1], series = "Historical Data") +
  ggtitle("Natural Gas - Neural Network") +
  ylab("Price (cents/kWh)")
```

```{r }
# neutral network model, temperature, fourier, UKRWAR performance

# neural network model performance for electricity data
nn_cov_e_perf <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.cov.e.forecast$mean)

# neural network model performance for gas data
nn_cov_gas_perf <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.cov.gas.forecast$mean)
```

Then we use seasonal arima model with temperature and fourier terms to model two series. UKRWAR is excluded because R reports no suitable ARIMA model when UKRWAR is included. Function used: auto.arima(xreg)

```{r}
# sarima with temperature and fourier terms for electricity

sarima.e.cov.forecast <- ts_electricity[, 2] %>% 
  window(end = c(2022, 1)) %>% 
  auto.arima(seasonal = FALSE, 
             xreg = covariates_train_e[, -1]) %>% 
  forecast(xreg = window(covariates_full_e[, -1], start = c(2022, 2)),
           h = 12)

autoplot(sarima.e.cov.forecast$mean, series = "ARIMA with Covariates") +
  autolayer(ts_electricity[, 2], series = "Historical Data") +
  ggtitle("Electricity - ARIMA with Covariates") +
  ylab("Price (cents/kWh)")

# arima with covariates for gas
sarima.gas.cov.forecast <- ts_gas_equiv[, 1] %>% 
  window(end = c(2022, 1)) %>% 
  auto.arima(seasonal = FALSE,
             xreg = covariates_train_gas[, -1]) %>% 
  forecast(xreg = window(covariates_full_gas[, -1], start = c(2022, 2)), 
           h = 12)

autoplot(sarima.gas.cov.forecast$mean, series = "SARIMA with Covariates") +
  autolayer(ts_gas_equiv[, 1], series = "Historical Data") +
  ylab("Price (cents/kWh)") +
  ggtitle("Natural Gas - SARIMA with Covariates") +
  theme(plot.title = element_text(hjust = 0.05))

```

```{r}
#  Examine Arima with fourier's performance on electricity and NG data

# model performance for electricity data
sarima_cov_e_perf <- ts_electricity[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(sarima.e.cov.forecast$mean)

# model performance for gas data
sarima_cov_gas_perf <- ts_gas_equiv[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(sarima.gas.cov.forecast$mean)

```


##Summary and Conclusions


## Use ETS to model -- not finished -- I don't know how to do this, maybe we don't need to include this

```{r}
# I think STL doesn't need fourier terms. So, I will get covariates dataframes without fourier terms
# because UKRWAR and temperature are the same across two data frames, we only need one
cov_train_nofour <- covariates_train_e[, 1:2]
colnames(cov_train_nofour) <- c("UKRWAR", "temperature")

cov_test_nofour <- covariates_full_e[, 1:2] %>% 
  window(start = c(2022, 2))
colnames(cov_test_nofour) <- c("UKRWAR", "temperature")

```



### compare performance scores and generate tables for use

```{r}
# plot these together
ts_electricity[, 2] %>% 
  window(start = c(2016, 1)) %>% 
  autoplot(series = "Historical Series") +
  autolayer(nn.e.forecast$mean, series = "Neural Network") +
  autolayer(arima.e.forecast$mean, series = "SARIMA") +
  autolayer(arima.e.four.forecast$mean, series = "ARIMA with Fourier Terms") +
  autolayer(stl.e.forecast$mean, series = "STL + EST") +
  autolayer(tbats.e.forecast$mean, series = "TBATS") +
  autolayer(nn.cov.e.forecast$mean, series = "Neural Network with Covariates") +
  autolayer(sarima.e.cov.forecast$mean, series = "SARIMA with Tem and Fourier") +
  ylab("Price (cents/kWh)") +
  ggtitle("Comparision of Four Modeling Methods - Electricity") +
  theme_classic()

  
ts_gas_equiv[, 1] %>% 
  window(start = c(2016, 1)) %>% 
  autoplot(series = "Historical Series") +
  autolayer(nn.gas.forecast$mean, series = "Neural Network") +
  autolayer(arima.gas.forecast$mean, series = "SARIMA") +
  autolayer(arima.gas.four.forecast$mean, series = "ARIMA with Fourier Terms") +
  autolayer(stl.gas.forecast$mean, series = "STL + EST") +
  autolayer(tbats.gas.forecast$mean, series = "TBATS") +
  autolayer(nn.cov.gas.forecast$mean,series = "Neural Network with Covariates") +
  autolayer(sarima.gas.cov.forecast$mean, series = "SARIMA with Tem and Fourier") +
  ylab("Price (cents/kWh)") +
  ggtitle("Comparision of Four Modeling Methods - Natural Gas") +
  theme_classic()

# scores for electricity
scores.e <- rbind(sarima_e_perf, 
                  arima_four_e_perf,
                  stl_e_perf,
                  nn_e_perf,
                  tbats_e_perf,
                  nn_cov_e_perf,
                  sarima_cov_e_perf
                  ) %>% 
  as.data.frame()

  # rename rows
row.names(scores.e) <- c("SARIMA", 
                         "ARIMA with Fourier", 
                         "STL",
                         "Neural Network",
                         "TBATS",
                         "Neural Network with Covariates",
                         "SARIMA with Tem and Fourier")

  # find the row index of the lowest RMSE
best.e.model <- scores.e$RMSE %>% 
  which.min() 

cat("The best model for electricity by RMSE is: ", 
    row.names(scores.e[best.e.model, ]))

# generate a visualized table to use in the report
kbl(scores.e,
    caption = "Forecast Accuracy for NC Residential Electricity Price",
    digits = array(5, ncol(scores.e))) %>% 
  kable_styling(full_width = FALSE, position = "center", 
                latex_options = "hold_position") %>% 
  kable_styling(latex_options = "striped", 
                stripe_index = best.e.model,
                stripe_color = "red")

# scores for gas
scores.gas <- rbind(sarima_gas_perf, 
                  arima_four_gas_perf,
                  stl_gas_perf,
                  nn_gas_perf,
                  tbats_gas_perf,
                  nn_cov_gas_perf,
                  sarima_cov_gas_perf) %>% 
  as.data.frame()

  # rename rows
row.names(scores.gas) <- c("SARIMA", 
                         "ARIMA with Fourier", 
                         "STL",
                         "Neural Network",
                         "TBATS",
                         "Neural Network with Covariates",
                         "SARIMA with Tem and Fourier")

  # find the row index of the lowest RMSE
best.gas.model <- scores.gas$RMSE %>% 
  which.min() 

cat("The best model for natural gas by RMSE is: ", 
    row.names(scores.gas[best.gas.model, ]))

# generate a visualized table to use in the report
kbl(scores.gas,
    caption = "Forecast Accuracy for NC Residential Natural Gas Price",
    digits = array(5, ncol(scores.gas))) %>% 
  kable_styling(full_width = FALSE, position = "center", 
                latex_options = "hold_position") %>% 
  kable_styling(latex_options = "striped", 
                stripe_index = best.gas.model,
                stripe_color = "red")
```

### Use STL to model electricity and natural gas for the next 12 month

```{r}

e.forecast.2324 <- ts_electricity[, 2] %>% 
  stlf(h = 12)

gas.forecast.2324 <- ts_gas_equiv[, 1] %>% 
  stlf(h = 12)

e.forecast.2324$mean %>% 
  autoplot() +
  autolayer(e.forecast.2324$mean, series = "electricity forecast for 23-24") +
  autolayer(gas.forecast.2324$mean, series = "gas forecast for 23-24") +
  autolayer(window(ts_electricity[, 2], start = c(2017, 1)), 
            series = "historical data for electricity") +
   autolayer(window(ts_gas_equiv[, 1], start = c(2017, 1)), 
            series = "historical data for natural gas") +
  theme_classic() +
  ggtitle("Forecast of Electricity and Natural Gas Price for the Next 12 Months") +
  ylab("Price (cents/kWh)")
  


```
