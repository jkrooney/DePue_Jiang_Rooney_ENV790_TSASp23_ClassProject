---
title: 'Winter Is Coming: Forecasting Electricity and Natural Gas Prices for Home
  Heating'
author: "Justin DePue, John Rooney, and Tony Jiang"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
  pdf_document: default
toc: yes
geometry: margin=2.54cm
fig_height: 3
fig_width: 4
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


```{r loading libraries, warning = FALSE, message = FALSE, include = FALSE}
library(tseries)
library(lubridate)
library(here)
library(tidyverse)
library(ggplot2)
library(forecast)
library(kableExtra)
library(readxl)

```


## Introduction
This study was born out of both curiosity and necessity. One of our teammates faced higher than expected energy bills this winter and was suddenly faced with the question of whether to shiver to save money or spend it on heating bills and be forced to eat Spaghetti-O's as sustenance. While spring has sprung and summer is on the horizon, we know that winter is coming and that we should prepare now in order that history not repeat itself. 

As students recently armed with the tools to conduct time series analysis and forecasting, we realized we could complete our final project while aiding our teammate with knowledge for the future. Our study question thus emerged: would it be more cost-effective to heat an apartment in North Carolina using electricity or a natural-gas powered heater? 

Full of optimism that we could complete a class requirement while doing some good for the world (for as Marvel taught us, when you help someone, you help everyone), we set out to find the data that would lead us to the answer we sought. Our journey led us to that great repository of energy knowledge, the US Energy Information Administration. There we found two datasets we felt confident would help us help our teammate: "North Carolina Price of Natural Gas Delivered to Residential Customers (Dollars Per Thousand Cubic Feet)", which contained monthly data from January 1989 through January 2023, and "Average Retail Price of Electricity by State and Sector" which contained monthly data from January 2001 through January 2023. 

## Data

Both datasets were downloaded from the EIA as .csv files. The most significant data wrangling was done with the natural gas data as it was originally provided in dollars per thousand cubic feet and needed to be in dollars per kilowatt hour for comparison with electricity data. The electricity data was provided monthly for both regions and states by sector. The natural gas data was provided monthly for North Carolina accompanied by price. 
```{r load and explore data, warning=FALSE, include=FALSE}

# automatically set the working directory as personal local path to R project
# so the file path in read.csv can work for everyone
setwd(here())

# load the data
electricity_prices.df <- read.csv("./Data/Average_retail_price_of_electricity.csv", header = TRUE, skip=4)

nc_electricity.df<-electricity_prices.df[228,4:(ncol(electricity_prices.df))] %>%
  pivot_longer(cols=everything(), names_to = 'my_date', values_to = 'price_per_kWh')

# examine whether there is missing value or not
electric_summary<-summary(nc_electricity.df)
# there is no missing value

nc_electricity.df$price_per_kWh<-as.numeric(nc_electricity.df$price_per_kWh)
  

# Import Natural Gas data

natural_gas.df <- read.csv("./Data/NC_NaturalGas.csv", header = TRUE, skip=2,col.names = c("year", "price"))

#Check for missing data. There is an extra empty row with an NA at the very end of the dataset, so I removed it with na.omit

gas_summary<-summarize(na.omit(natural_gas.df))
```


```{r, echo=FALSE,fig.pos='H'}
#electric summary variables
mean.elec<-round(mean(nc_electricity.df$price_per_kWh,na.rm = TRUE),2)

length.elec<-length(nc_electricity.df$price_per_kWh)

sd.elec<-round(sd(nc_electricity.df$price_per_kWh,na.rm = TRUE),2)

median.elec<-round(median(nc_electricity.df$price_per_kWh,na.rm = TRUE),2)

min.elec<-min(nc_electricity.df$price_per_kWh,na.rm = TRUE)

max.elec<-max(nc_electricity.df$price_per_kWh,na.rm = TRUE)


#create summary DF for electricity
summary_elec<- cbind(length.elec, min.elec, max.elec, mean.elec, sd.elec, median.elec
                  ) %>% 
  as.data.frame()

# rename columns
colnames(summary_elec) <- c("Observations",
                          "Min",
                          "Max",
                          "Mean Price",
                         "Std. Dev.", 
                         "Median Price"
                            )

#gas summary variables
mean.gas<-round(mean(natural_gas.df$price,na.rm = TRUE),2)

length.gas<-length(natural_gas.df$price)

sd.gas<-round(sd(natural_gas.df$price,na.rm = TRUE),2)

median.gas<-round(median(natural_gas.df$price,na.rm = TRUE),2)

min.gas<-min(natural_gas.df$price,na.rm = TRUE)

max.gas<-max(natural_gas.df$price,na.rm = TRUE)

# create summary DF for gas
summary_gas<- cbind(length.gas, min.gas, max.gas, mean.gas, sd.gas, median.gas
                  ) %>% 
  as.data.frame()

# rename columns
colnames(summary_gas) <- c("Observations",
                          "Min",
                          "Max",
                          "Mean Price",
                         "Std. Dev.", 
                         "Median Price")

summary_data<-rbind(summary_gas, summary_elec)

summary_data$Variable<-c("Natural Gas ($/Mcf)","Electricity(cents/kWh)")

summary_data<-summary_data[,c(7,1,2,3,4,5,6)]


# generate a visualized table to use in the report
kbl(summary_data,
    caption = "Table 1: Summary Statistics",
    digits = array(5, ncol(summary_data))) %>% 
  kable_styling(full_width = FALSE, position = "center", 
                latex_options = "HOLD_position") %>% 
  kable_styling(latex_options = "striped")
```

```{r, echo=FALSE, fig.pos='H'}
# show top 10 rows of data

    d1 <- head(natural_gas.df, 10)
    d2 <- head(nc_electricity.df,10)
    
 p1<-kbl(d1,
    caption = "Sample of Cleaned Natural Gas Data") %>% 
  kable_styling(full_width = FALSE, position = "center", 
                latex_options = "HOLD_position") %>% 
  kable_styling(latex_options = "striped")
  
p2<-kbl(d2,
    caption = "Sample of Cleaned Electricity Data") %>% 
  kable_styling(full_width = FALSE, position="center", wraptable_width = "1cm",
                latex_options = "HOLD_position") %>% 
  kable_styling(latex_options = "striped")
  
par(mfrow=c(1,2))
p1
p2
  
```

## Analysis
Our analysis began by creating initial time series objects and plotting them, along with creating ACF and PACF plots to gain an initial sense of what the series looked like and what seasonality they may have. 

We then decomposed the time series objects for further analysis to visualize the trend and seasonality of each series. The decomposition of the natural gas time series object shows clear seasonality in price along with a steep upward trend beginning in 2020. The decomposition of electricity prices shows a clear upward trend from the beginning of the series and shows a bimodal seasonality.

```{r create time series for natural gas, include=FALSE}
#create timeseries for natural gas

ts_NG<-ts(na.omit(natural_gas.df[,2]), start=c(1989,1), frequency=12)
```

```{r plot initial time series, include=FALSE}
# plot raw time series
plot(ts_NG, col="blue", ylab="$/Mcf", xlab="Date", main="NC Residential Natural Gas Cost")
```

```{r, warning=FALSE, include=FALSE}
# convert natural gas data from $/Mcf to $/kWh based on 80% heating efficiency
# $/kWh = [($/mcf/1.037)/293.07107]/0.9 = $/mcf/273.52


conversion <- 0.8*293.07107*1.037/100


natural_gas.df$kwh_equiv<-((natural_gas.df$price)/conversion)


natural_gas.df<-na.omit(natural_gas.df)

ts_gas_equiv<-ts(natural_gas.df[,3], start=c(1989,1), frequency=12)

ts_gas_equiv<-window(ts_gas_equiv, start=c(2001, 1))

#plot gas TS in kw/hr equiv
autoplot(ts_gas_equiv) +
  ylab("Price (cents/kWh") + 
  ggtitle("NC Residential Natural Gas Cost (cents/kWh)")


# coerce electricity to a time series object

ts_electricity<-ts(rev(nc_electricity.df[,2]), start=c(2001,1), frequency=12)

plot(ts_electricity, col="red", ylab="Price (cents/kWh)", xlab="Date", main="NC Residential Electricity Cost")


#Create Dataframe with both Gas & Electricity prices...
#create new date column
new_date<-seq(as.Date("2001/1/1"), by = "month", length.out = nrow(ts_electricity))

#bind date, gas, & electricity
nc_energy.df<-cbind.data.frame("Month_Date"=new_date, 
                               "electricity"=nc_electricity.df$price_per_kWh, 
                               "gas_equiv"=ts_gas_equiv)

#Subtract Gas price from Electricity price
nc_energy.df$cost_diff <- nc_energy.df$electricity - nc_energy.df$gas_equiv

```

```{r plot elec and gas ts, echo=FALSE}
#plot both electric & gas TS together
ts.plot(ts_gas_equiv, ts_electricity, gpars = list(col = c("red", "blue")), 
        xlab="Date", ylab="cents/kWh", 
        main="Comparison of Natural Gas and Electricity Costs")
legend("topleft", bty="n", lty=c(1,1), col=c("red","blue"),
       legend=c(" Natural Gas ", " Electricity "))
```


 

```{r decompose ts, echo=FALSE}
#Decompose TS

decomp_elec<-decompose(ts_electricity, type="additive")
decomp_gas<-decompose(ts_gas_equiv, type="multiplicative")

ts_gas_equiv %>% 
  window(start = c(2013,1), end = c(2023,1)) %>%
  stl(s.window = "periodic") %>% 
  plot()

plot(decomp_elec)

#remove seasonality
ts_elec_ns<-(ts_electricity - decomp_elec$seasonal)
ts_gas_ns<-(ts_gas_equiv - decomp_gas$seasonal)

```

```{r ACF and PACF of electricity and natural gas, echo=FALSE}

# ACF and PACF of electricity data
par(mfrow=c(1,2))
Acf(ts_electricity[,1], lag.max=40, main="ACF Electricity")
Acf(ts_elec_ns, lag.max=40, main="ACF Non-Seasonal Electricity")

par(mfrow=c(1,2))
Pacf(ts_electricity[,1], lag.max=40, main="PACF Electricity")
Pacf(ts_elec_ns, lag.max=40, main="PACF Non-Seasonal Electricity")

# ACF and PACF of natural gas data
par(mfrow=c(1,2))
Acf(ts_gas_equiv, lag.max=40, main="ACF Natural Gas")
Acf(ts_gas_ns, lag.max=40, main="ACF Non-Seasonal Gas")

par(mfrow=c(1,2))
Pacf(ts_gas_equiv, lag.max=40, main="PACF Natural Gas")
Pacf(ts_gas_ns, lag.max=40, main="PACF Non-Seasonal Gas")
```

Several models were developed and tested to determine what would best fit the data we had and what may lead to the best forecast to determine whether heating via electricity or natural gas would be most cost-efficient in the upcoming winter. The five that were used were the Seasonal ARIMA, ARIMA with Fourier terms, Neural Networks, TBATS, and STL + EST.

Each of these tests used functions from the "forecast" library and required the use of time series data which we created using the "ts" function from the "tseries" library.

While the Seasonal ARIMA was a logical first model to try, we quickly felt that the performance was not particularly strong and that developing and testing other models was warranted. 

```{r Seasonal Arima, echo=FALSE}
#forecast Electricity SARIMA

arima.e.model<-auto.arima(window(ts_electricity, end=c(2022,1)))
arima.e.forecast<-forecast(arima.e.model, h=12)

autoplot(ts_electricity) +
  autolayer(arima.e.forecast$mean, series = "SARIMA") +
  ylab("Price (cents/kWh)") +
  ggtitle("Electricity - SARIMA")
  # performance is not that good

#Gas SARIMA forecast
arima.gas.model<-auto.arima(window(ts_gas_equiv, end=c(2022,1)))
arima.gas.forecast<-forecast(arima.gas.model, h=12)

autoplot(ts_gas_equiv)+
  autolayer(arima.gas.forecast$mean, series = "SARIMA") +
  ylab("Price (cents/kWh)") +
  ggtitle("Natural Gas - SARIMA")
  # performance is not that good
```

```{r examine SARIMA performance, echo=FALSE}

# model performance for electricity data
sarima_e_perf <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(arima.e.forecast$mean)


# model performance for gas data
sarima_gas_perf <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(arima.gas.forecast$mean)

```
We decided to explore more advanced models such as the ARIMA with Fourier Terms model, Neural Networks, TBATS, and STL + EST.
ARIMA with Fourier terms is known as a dynamic harmonic regression model with an ARMA error structure, using the "fourier" function from package "forecast" to find terms that model seasonal components. 

```{r Arima with Fourier terms, echo=FALSE}
# arima with fourier terms for eletricity
arima.e.four.forecast <- ts_electricity %>% 
  window(end = c(2022, 1)) %>% 
  auto.arima(seasonal = FALSE, 
             xreg = fourier(window(ts_electricity, end = c(2022, 1)), 
                            K = 6)) %>% 
  forecast(xreg = fourier(window(ts_electricity, 
                                 start = c(2022,2)
                                 ),
                            K = 6),
           h = 12)

autoplot(arima.e.four.forecast$mean, series = "ARIMA with Fourier Terms") +
  autolayer(ts_electricity, series = "Historical Data") +
  ggtitle("Electricity - ARIMA with Fourier Terms") +
  ylab("Price (cents/kWh)")

# arima with fourier terms for gas
arima.gas.four.forecast <- ts_gas_equiv %>% 
  window(end = c(2022, 1)) %>% 
  auto.arima(seasonal = FALSE,
             xreg = fourier(window(ts_gas_equiv, end = c(2022, 1)), 
                            K = 6)
             ) %>% 
  forecast(xreg = fourier(window(ts_gas_equiv, 
                                 start = c(2022, 2)
                                 ),
                          K = 6), 
           h = 12)

autoplot(arima.gas.four.forecast$mean, series = "ARIMA with Fourier Terms") +
  autolayer(ts_gas_equiv, series = "Historical Data") +
  ggtitle("Natural Gas - ARIMA with Fourier Terms") +
  ylab("Price (cents/kWh)")

```

```{r, echo=FALSE}

#Examine Arima with fourier performance on electricity and NG data
# model performance for electricity data
arima_four_e_perf <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(arima.e.four.forecast$mean)

# model performance for gas data
arima_four_gas_perf <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(arima.gas.four.forecast$mean)

```
&nbsp;
&nbsp;

We next developed and tested an STL model.

&nbsp;
&nbsp;
```{r STL , echo=FALSE}

# STL for electricity
stl.e.forecast <- ts_electricity %>% 
  window(end = c(2022, 1)) %>% 
  stlf(h = 12)

autoplot(stl.e.forecast$mean, series = "STL + ETS") +
  autolayer(ts_electricity, series = "Historical Data") +
  ggtitle("Electricity - STL + EST") +
  ylab("Price (cents/kWh)")

# STL for gas
stl.gas.forecast <- ts_gas_equiv %>% 
  window(end = c(2022, 1)) %>% 
  stlf(h = 12)

autoplot(ts_gas_equiv, series = "Historical Data") +
  autolayer(stl.gas.forecast$mean, series = "STL + ETS") +
  ggtitle("Natural Gas - STL + EST") +
  ylab("Price (cents/kWh)")
```


```{r, echo=FALSE }
#Examine STLs performance on electricity and NG data
# model performance for electricity data
stl_e_perf <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(stl.e.forecast$mean)

# model performance for gas data
stl_gas_perf <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(stl.gas.forecast$mean)

```
&nbsp;
&nbsp;

We then developed and test a neural network model using the "nnetar()" function in the "forecast" package. We learned that the p and P arguments in nnetar() have significant impact on model performance. Therefore, we worked to identify the optimal p and P combination through trial and error.

&nbsp;
&nbsp;
```{r, echo=FALSE, position="H" }
# find the optimal p and P values for neural network without fourier for electricity series

## p = 1, P = 0
nn.e.forecast.10 <- ts_electricity %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 0, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.10.score <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.10$mean)

## p = 1, P = 1
nn.e.forecast.11 <- ts_electricity %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.11.score <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.11$mean)

## p = 2, P = 0
nn.e.forecast.20 <- ts_electricity %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 0, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.20.score <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.20$mean)

## p = 2, P = 1
nn.e.forecast.21 <- ts_electricity %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.21.score <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.21$mean)

## p = 2, P = 2
nn.e.forecast.22 <- ts_electricity %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 2, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.22.score <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.22$mean)

## p = 1, P = 2
nn.e.forecast.12 <- ts_electricity %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 2, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.12.score <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.12$mean)

## p = 3, P = 1
nn.e.forecast.31 <- ts_electricity %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 3, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.e.31.score <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast.31$mean)

nn.e.scores <- rbind(nn.e.10.score, nn.e.11.score, nn.e.20.score, nn.e.21.score,
                   nn.e.22.score, nn.e.12.score, nn.e.31.score)

row.names(nn.e.scores) <- c("1/0", "1/1", "2/0", "2/1", "2/2", "1/2", "3/1")

## 11 has the lowest RMSE and 12 has the lowest MAPE


kbl(nn.e.scores,
    caption = "Natural Gas Neural Net Forecast Accuracy using Various Seasonal Lag Inputs (p/P)",
    digits = array(5, ncol(nn.e.scores))) %>% 
  kable_styling(full_width = FALSE, position = "center", 
                latex_options = "HOLD_position") %>% 
  kable_styling(latex_options = "striped"
                )

```

```{r, echo=FALSE, position="H"}
# find the optimal p and P values for neural network without fourier for natural gas series

## p = 1, P = 0
nn.gas.forecast.10 <- ts_gas_equiv %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 0, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.10.score <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.10$mean)

## p = 1, P = 1
nn.gas.forecast.11 <- ts_gas_equiv %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.11.score <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.11$mean)

## p = 2, P = 0
nn.gas.forecast.20 <- ts_gas_equiv %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 0, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.20.score <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.20$mean)

## p = 2, P = 1
nn.gas.forecast.21 <- ts_gas_equiv %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.21.score <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.21$mean)

## p = 2, P = 2
nn.gas.forecast.22 <- ts_gas_equiv %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 2, P = 2, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.22.score <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.22$mean)

## p = 1, P = 2
nn.gas.forecast.12 <- ts_gas_equiv %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 2, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.12.score <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.12$mean)

## p = 3, P = 1
nn.gas.forecast.31 <- ts_gas_equiv %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 3, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.31.score <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.31$mean)

## p = 3, P = 2
nn.gas.forecast.32 <- ts_gas_equiv %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 3, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.32.score <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.32$mean)

## p = 3, P = 3
nn.gas.forecast.33 <- ts_gas_equiv %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 3, P = 3, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         ) %>% 
  forecast(h = 12)

nn.gas.33.score <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast.33$mean)

nn.gas.scores <- rbind(nn.gas.10.score, nn.gas.11.score, nn.gas.20.score, nn.gas.21.score,
                   nn.gas.22.score, nn.gas.12.score, nn.gas.31.score, nn.gas.32.score, 
                   nn.gas.33.score)

row.names(nn.gas.scores) <- c("1/0", "1/1", "2/0", "2/1", "2/2", "1/2", "3/1", "3/2", "33")



kbl(nn.gas.scores,
    caption = "Natural Gas Neural Net Forecast Accuracy using Various Seasonal Lag Inputs (p/P)",
    digits = array(5, ncol(nn.gas.scores))) %>% 
  kable_styling(full_width = FALSE, position = "center", 
                latex_options = "HOLD_position") %>% 
  kable_styling(latex_options = "striped")

 ## 3/2 has the lowest RMSE and 1/1 has the lowest MAPE

```
&nbsp;
&nbsp;

We found that combination 11 (p = 1 and P = 1) had the best modeling performance for our electricity series, and combination 32 (p = 3 and P = 2) had the best modeling performance for our natural gas series. We then used combination 11 to run a neural network model with fourier terms for our electricity series.

&nbsp;
&nbsp;
```{r, echo=FALSE }
#Use Neural Network and fourier to model

# neural network forecast for electricity data
nn.e.forecast <- ts_electricity %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 1, # 2 and 1 are randomly decided. To find the optimal one, 
         # we need to run a couple of combinations to find the best one
         xreg = fourier(window(ts_electricity, 
                               end = c(2022, 1)
                               ),
                        K = 6)
         ) %>% 
  forecast(xreg = fourier(window(ts_electricity, 
                                 start = c(2022, 2)
                                 ),
                          K = 6),
           h = 12)

# neural network forecast for gas data
nn.gas.forecast <- ts_gas_equiv %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 1,
         xreg = fourier(window(ts_gas_equiv, 
                               end = c(2022, 1)
                               ),
                        K = 6)
         ) %>% 
  forecast(xreg = fourier(window(ts_gas_equiv, 
                                 start = c(2022, 2)
                                 ),
                          K = 6),
           h = 12)


autoplot(nn.e.forecast$mean, series = "Neural Network") +
  autolayer(ts_electricity, series = "Historical Data") +
  ggtitle("Electricity - Neural Network") +
  ylab("Price (cents/kWh)")


```
```{r}
autoplot(nn.gas.forecast$mean, series = "Neural Network") +
  autolayer(ts_gas_equiv, series = "Historical Data") +
  ggtitle("Natural Gas - Neural Network") +
  ylab("Price (cents/kWh equiv)")
```


```{r, echo=FALSE }
# neutral network model performance

# neural network model performance for electricity data
nn_e_perf <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.e.forecast$mean)

# neural network model performance for gas data
nn_gas_perf <- ts_gas_equiv %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.gas.forecast$mean)
```
&nbsp;
&nbsp;

We then developed and tested a TBATS models for our electricity and natural gas series.

&nbsp;
&nbsp;

```{r, echo=FALSE, warning=FALSE}
# TBATS model

# TBATS for electricity
tbats.e.forecast <- ts_electricity %>% 
  window(end = c(2022, 1)) %>% 
  tbats() %>% 
  forecast(h = 12)

# TBATS for natural gas
tbats.gas.forecast <- ts_gas_equiv %>% 
  window(end = c(2022, 1)) %>% 
  tbats() %>% 
  forecast(h = 12)

autoplot(tbats.e.forecast$mean, series = "TBATS") +
  autolayer(ts_electricity, series = "Historical Data") +
  ggtitle("Electricity - TBATS") +
  ylab("Price (cents/kWh)")
```

&nbsp;
&nbsp;

```{r, echo=FALSE}

autoplot(tbats.gas.forecast$mean, series = "TBATS") +
  autolayer(ts_gas_equiv, series = "Historical Data") +
  ggtitle("Natural Gas - TBATS") +
  ylab("Price (cents/kWh equiv)")
```
&nbsp;
&nbsp;

```{r, echo=FALSE}
# TBATS model performance

# TBATS model performance for electricity data
tbats_e_perf <- ts_electricity %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(tbats.e.forecast$mean)

# TBATS model performance for gas data
tbats_gas_perf <- ts_gas_equiv%>% 
  window(start = c(2022, 2)) %>% 
  accuracy(tbats.gas.forecast$mean)
```
&nbsp;
&nbsp;

As we thought about other ways to model our time series, we realized that the Ukraine War has had a significant impact on natural gas prices, and likely eletricity price, too. We additionally realized temperature would be a good regressor to include since utility bills normally fluctuate in the same direction as temperature. Therefore, we created two covariates: UKRWAR and temperature. $UKRWAR$ is an indicator variable with values of 0 and 1. Months before March 2022 have a value of 0, while months after and including March 2022 have a value of 1. The reason why we set the cutoff month at March 2022 despite the war starting in February of that year is because the impact of the war on monthly natural gas prices in February 2022 should be limited because of the war beginning that month. The temperature series is the monthly average temperature of the Raleigh area. This is largest geographic level of historical temperature data.

&nbsp;
&nbsp;
```{r, echo=FALSE}
# add covariates

# create an indicator variable for Ukraine War for gas

# create a column with row index
natural_gas.df <- rownames_to_column(natural_gas.df, var = "index")

natural_gas.df$index = as.numeric(natural_gas.df$index)

natural_gas.df$UKRWAR <- ifelse(natural_gas.df$index >= 399, 1, 0)

natural_gas.df <- natural_gas.df[, c(-1, -6)]

ts_gas_equiv_war<-ts(natural_gas.df[,c(3,4)], start=c(1989,1), frequency=12) %>% 
  window(start = c(2001, 1))

# create an indicator variable for Ukraine War for electricity
nc_electricity.df <- rownames_to_column(nc_electricity.df, var = "index")

nc_electricity.df$index <- as.numeric(nc_electricity.df$index)

nc_electricity.df$UKRWAR <- ifelse(nc_electricity.df$index >= 255, 1, 0)

nc_electricity.df <- nc_electricity.df[, -1]

# coerce electricity to a time series object

ts_electricity_war<-ts(rev(nc_electricity.df[,2:3]), start=c(2001,1), frequency=12)


# import temperature data
temperautre <- read_xlsx("./Data/Raleigh Temperature.xlsx") %>% 
  gather(key = "Month", value = "temperature", Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)

temperautre <- temperautre[order(temperautre$Year), ] 

ts_temperature <- temperautre[,3] %>% 
  na.omit() %>% 
  ts(start = c(1995, 1), frequency = 12) %>% 
  window(start = c(2001, 1), end = c(2023, 1))

# create a data frame for covariates for electricity (2001-2022)
# we need to do this because electricity and natural gas 
# have different fourier terms
fourier_train_e <- fourier(window(ts_electricity_war[, 2],
                                end = c(2022, 1)),
                         K = 6)

covariates_train_e <- ts_electricity_war[, 1] %>% 
  window(end = c(2022, 1)) %>% 
  cbind(window(ts_temperature, end = c(2022,1)),
        fourier_train_e)


# create covariates data frame for electricity (2001-2023)
fourier_full_e <- fourier(window(ts_electricity_war[, 2],
                                end = c(2023, 1)),
                         K = 6)

covariates_full_e <- cbind(ts_electricity_war[, 1], ts_temperature, fourier_full_e)

# create covariates data frame for natural gas (2001-2022)
fourier_train_gas <- fourier(window(ts_gas_equiv_war[, 1],
                                end = c(2022, 1)),
                         K = 6)

covariates_train_gas <- ts_gas_equiv_war[, 2] %>% 
  window(end = c(2022, 1)) %>% 
  cbind(window(ts_temperature, end = c(2022,1)
               ),
        fourier_train_gas)


# create covariates data frame for electricity (2001-2023)
fourier_full_gas <- fourier(window(ts_gas_equiv_war[, 1],
                                end = c(2023, 1)),
                         K = 6)

covariates_full_gas <- cbind(ts_gas_equiv_war[, 2], ts_temperature, fourier_full_gas)
  
```
&nbsp;
&nbsp;

After creating all the covariates, we repeated our modeling but with covariates to improve the accuracy of the models. First we incorporated covariates into our neural network model.

&nbsp;
&nbsp;

```{r, echo=FALSE, warning=FALSE}
# Use Neural Network, temperature, UKRWAR, and fourier to model

# neural network forecast for electricity data
nn.cov.e.forecast <- ts_electricity_war[, 2] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 1,
         xreg = covariates_train_e[, -1]) %>% 
  forecast(xreg = window(covariates_full_e[, -1], start = c(2022, 2)),
           h = 12)

# neural network forecast for gas data
nn.cov.gas.forecast <- ts_gas_equiv_war[, 1] %>% 
  window(end = c(2022 ,1)) %>% 
  nnetar(p = 1, P = 1,
         xreg = covariates_train_gas[, -1]) %>% 
  forecast(xreg = window(covariates_full_gas[, -1], start = c(2022, 2)),
           h = 12)

autoplot(nn.cov.e.forecast$mean, series = "Neural Network") +
  autolayer(ts_electricity_war[, 2], series = "Historical Data") +
  ggtitle("Electricity - Neural Network") +
  ylab("Price (cents/kWh)")

```

&nbsp;
&nbsp;
```{r, echo=FALSE}
autoplot(nn.cov.gas.forecast$mean, series = "Neural Network") +
  autolayer(ts_gas_equiv_war[, 1], series = "Historical Data") +
  ggtitle("Natural Gas - Neural Network") +
  ylab("Price (cents/kWh)")
```

&nbsp;
&nbsp;
```{r, echo=FALSE, warning=FALSE }
# neutral network model, temperature, fourier, UKRWAR performance

# neural network model performance for electricity data
nn_cov_e_perf <- ts_electricity_war[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.cov.e.forecast$mean)

# neural network model performance for gas data
nn_cov_gas_perf <- ts_gas_equiv_war[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(nn.cov.gas.forecast$mean)
```
&nbsp;
&nbsp;

We then developed a seasonal arima model with temperature and fourier terms to model two series. UKRWAR as a covariate was excluded because R reported no suitable ARIMA model when UKRWAR was included. The function used for this was "auto.arima(xreg)".

&nbsp;
&nbsp;

```{r, echo=FALSE, warning=FALSE}
# sarima with temperature and fourier terms for electricity

sarima.e.cov.forecast <- ts_electricity_war[, 2] %>% 
  window(end = c(2022, 1)) %>% 
  auto.arima(seasonal = FALSE, 
             xreg = covariates_train_e[, -1]) %>% 
  forecast(xreg = window(covariates_full_e[, -1], start = c(2022, 2)),
           h = 12)

autoplot(sarima.e.cov.forecast$mean, series = "ARIMA with Covariates") +
  autolayer(ts_electricity_war[, 2], series = "Historical Data") +
  ggtitle("Electricity - ARIMA with Covariates") +
  ylab("Price (cents/kWh)")

# arima with covariates for gas
sarima.gas.cov.forecast <- ts_gas_equiv_war[, 1] %>% 
  window(end = c(2022, 1)) %>% 
  auto.arima(seasonal = FALSE,
             xreg = covariates_train_gas[, -1]) %>% 
  forecast(xreg = window(covariates_full_gas[, -1], start = c(2022, 2)), 
           h = 12)

```

&nbsp;
&nbsp;
```{r, echo=FALSE}
autoplot(sarima.gas.cov.forecast$mean, series = "SARIMA with Covariates") +
  autolayer(ts_gas_equiv_war[, 1], series = "Historical Data") +
  ylab("Price (cents/kWh)") +
  ggtitle("Natural Gas - SARIMA with Covariates") +
  theme(plot.title = element_text(hjust = 0.05))
```

&nbsp;
&nbsp;
```{r, echo=FALSE, warning=FALSE}
#Examine Arima with fourier performance on electricity and NG data model performance for electricity data
sarima_cov_e_perf <- ts_electricity_war[, 2] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(sarima.e.cov.forecast$mean)

# model performance for gas data
sarima_cov_gas_perf <- ts_gas_equiv_war[, 1] %>% 
  window(start = c(2022, 2)) %>% 
  accuracy(sarima.gas.cov.forecast$mean)

```
&nbsp;
&nbsp;

## Summary and Conclusions
When comparing the accuracy of each of the models that were tested, the STL model emerged as the best fit for both the price of electricity and the price of natural gas when comparing both the RMSE and MAPE scores. Both models missed the heights seen in 2022, however. There could be several reasons for this. One is the difficulty of modeling for the beginning of the war in Ukraine and the impact that has had on natural gas prices both regionally and around the world. Another is the difficulty of modeling for the influence of generationally high inflation. With both of these compounding each other, it is perhaps not surprising that all of the models failed to predict the rise in price for both electricity and natural gas. 

```{r, echo=FALSE, warning=FALSE}
# I think STL doesn't need fourier terms. So, I will get covariates dataframes without fourier terms
# because UKRWAR and temperature are the same across two data frames, we only need one
cov_train_nofour <- covariates_train_e[, 1:2]
colnames(cov_train_nofour) <- c("UKRWAR", "temperature")

cov_test_nofour <- covariates_full_e[, 1:2] %>% 
  window(start = c(2022, 2))
colnames(cov_test_nofour) <- c("UKRWAR", "temperature")

```

&nbsp;
&nbsp;


```{r compare performace scores and generate tables for use, echo=FALSE, warning=FALSE}
# plot these together
ts_electricity %>% 
  window(start = c(2016, 1)) %>% 
  autoplot(series = "Historical Series") +
  autolayer(nn.e.forecast$mean, series = "Neural Network") +
  autolayer(arima.e.forecast$mean, series = "SARIMA") +
  autolayer(arima.e.four.forecast$mean, series = "ARIMA with Fourier Terms") +
  autolayer(stl.e.forecast$mean, series = "STL + EST") +
  autolayer(tbats.e.forecast$mean, series = "TBATS") +
  autolayer(nn.cov.e.forecast$mean, series = "Neural Network with Covariates") +
  autolayer(sarima.e.cov.forecast$mean, series = "SARIMA with Tem and Fourier") +
  ylab("Price (cents/kWh)") +
  ggtitle("Comparision of Modeling Methods - Electricity") +
  theme_classic()

  
ts_gas_equiv %>% 
  window(start = c(2016, 1)) %>% 
  autoplot(series = "Historical Series") +
  autolayer(nn.gas.forecast$mean, series = "Neural Network") +
  autolayer(arima.gas.forecast$mean, series = "SARIMA") +
  autolayer(arima.gas.four.forecast$mean, series = "ARIMA with Fourier Terms") +
  autolayer(stl.gas.forecast$mean, series = "STL + EST") +
  autolayer(tbats.gas.forecast$mean, series = "TBATS") +
  autolayer(nn.cov.gas.forecast$mean,series = "Neural Network with Covariates") +
  autolayer(sarima.gas.cov.forecast$mean, series = "SARIMA with Tem and Fourier") +
  ylab("Price (cents/kWh)") +
  ggtitle("Comparision of Modeling Methods - Natural Gas") +
  theme_classic()

# scores for electricity
scores.e <- rbind(sarima_e_perf, 
                  arima_four_e_perf,
                  stl_e_perf,
                  nn_e_perf,
                  tbats_e_perf,
                  nn_cov_e_perf,
                  sarima_cov_e_perf
                  ) %>% 
  as.data.frame()

  # rename rows
row.names(scores.e) <- c("SARIMA", 
                         "ARIMA with Fourier", 
                         "STL",
                         "Neural Network",
                         "TBATS",
                         "Neural Network with Covariates",
                         "SARIMA with Tem and Fourier")

  # find the row index of the lowest RMSE
best.e.model <- scores.e$RMSE %>% 
  which.min() 

cat("The best model for electricity by RMSE is: ", 
    row.names(scores.e[best.e.model, ]))

# generate a visualized table to use in the report
kbl(scores.e,
    caption = "Forecast Accuracy for NC Residential Electricity Price",
    digits = array(5, ncol(scores.e))) %>% 
  kable_styling(full_width = FALSE, position = "center", 
                latex_options = "hold_position") %>% 
  kable_styling(latex_options = "striped", 
                stripe_index = best.e.model,
                stripe_color = "red")

# scores for gas
scores.gas <- rbind(sarima_gas_perf, 
                  arima_four_gas_perf,
                  stl_gas_perf,
                  nn_gas_perf,
                  tbats_gas_perf,
                  nn_cov_gas_perf,
                  sarima_cov_gas_perf) %>% 
  as.data.frame()

  # rename rows
row.names(scores.gas) <- c("SARIMA", 
                         "ARIMA with Fourier", 
                         "STL",
                         "Neural Network",
                         "TBATS",
                         "Neural Network with Covariates",
                         "SARIMA with Tem and Fourier")

  # find the row index of the lowest RMSE
best.gas.model <- scores.gas$RMSE %>% 
  which.min() 

cat("The best model for natural gas by RMSE is: ", 
    row.names(scores.gas[best.gas.model, ]))

# generate a visualized table to use in the report
kbl(scores.gas,
    caption = "Forecast Accuracy for NC Residential Natural Gas Price",
    digits = array(5, ncol(scores.gas))) %>% 
  kable_styling(full_width = FALSE, position = "center", 
                latex_options = "hold_position") %>% 
  kable_styling(latex_options = "striped", 
                stripe_index = best.gas.model,
                stripe_color = "red")
```
&nbsp;
&nbsp;

Our initial research question posed how our roommate could best plan for surviving, if not thriving, in the upcoming winter. Based on our analysis, the answer appears to be that he would be best off by buying a natural gas-powered heater. Given the vicissitudes of energy prices seen in recent months, and the uncertainty of global and domestic events that could further impact energy prices, this is hard to say with certainty as is the case with all forecasts. Revisiting these forecasts both ahead of the upcoming winter and annually thereafter with updated data would be well-advised. 

```{r, echo=FALSE, warning=FALSE}

e.forecast.2324 <- ts_electricity_war[, 2] %>% 
  stlf(h = 12)

gas.forecast.2324 <- ts_gas_equiv_war[, 1] %>% 
  stlf(h = 12)

e.forecast.2324$mean %>% 
  autoplot() +
  autolayer(e.forecast.2324$mean, series = "electricity forecast for 23-24") +
  autolayer(gas.forecast.2324$mean, series = "gas forecast for 23-24") +
  autolayer(window(ts_electricity_war[, 2], start = c(2017, 1)), 
            series = "historical data for electricity") +
   autolayer(window(ts_gas_equiv_war[, 1], start = c(2017, 1)), 
            series = "historical data for natural gas") +
  theme_classic() +
  ggtitle("Forecast of Electricity and Natural Gas Price for the Next 12 Months") +
  ylab("Price (cents/kWh)")
  


```
